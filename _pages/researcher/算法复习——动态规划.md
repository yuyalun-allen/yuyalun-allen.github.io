# 算法复习——动态规划

动态规划是算法中的重要思想。我们从算法的定义入手，算法是在给定大量输入的情况下高效地发现符合要求的解的步骤。
有一些特性：

- 确定性
- 有限性
- 输入
- 输出
- 可行性

动态规划实现自然也需要考虑这些特性。

## 与贪心和穷举的对比

贪心典型的做法就是选择一种局部可行且最优的情况，往往可以在较低的复杂度内在某些情况下（甚至是所有情况下）得到比较好的效果，但在大多数情况下是不保证正确性的。

穷举法的做法就是列出所有可能的输出，比较它们哪种更加优秀，可以严格保证正确性，然而优化不当会导致复杂度过高。

没有优化的穷举法往往被称为“暴力枚举”，~~其实有时候枚举也没那么简单~~，**动态规划**就是对于穷举法的典型的优化思路。

动态规划优化的核心就是不做重复计算，复用计算好的结果。很多时候在我们观察**暴力枚举**过程中就会情不自禁地感到很多计算都浪费了，那么这时候按照动态规划的思想去掉重复计算就顺理成章了。

## 核心思想

既然不想做重复计算，那就要好好规划一番，有以下三个要点：

1. 子问题
1. 子问题的关系
1. 计算顺序

> 动态规划有些情况下也用到分治法的思想，两种思想是互补的。

在某种计算顺序下，按照子问题的关系可以从最基本的子问题逐步推导到完整问题的答案。一句话概括动态规划的思想，就是这样。一类最值得考虑的子问题是**最基本的子问题**，子问题的关系往往被称为**动态规划递推式**，计算顺序如何从**最基本子问题**开始，并且在后续计算时总能通过子问题关系用上已经计算好的子问题，这些问题是动态规划方法中需要考虑的重要问题。

## 矩阵乘法最少次数的例子

最基本子问题的当然是，一个矩阵乘法永远都不需要计算，计算次数为0，两个矩阵乘法计算次数也别无他法，计算次数为 $d_i * d_j * d_k$。

子问题的关系是，一系列矩阵乘法，经过各种不同结合顺序最后一定可以写为两个矩阵相乘，最终的最少次数就是得到这些矩阵二元组已经使用的次数与最后两个矩阵相乘需要的次数的最少值。

计算顺序是，从1个矩阵逐步扩展到所有矩阵，用 $d_{start}$ 和 $d_{end}$ 来控制考虑的矩阵范围，最开始 start = n-1, end = n （最后一个矩阵自己乘），最后start = 1, end = n。根据子问题的关系，计算最终乘法数量时需要得到左右两个子问题矩阵的乘法数量。

## 最长公共子序列（Longest Common Sequencem, LCS）的例子

最基本的问题是，空字符串 LCS = 0，如果两个字符相等那么他们对应的字符串 LCS = 1，否则 LCS = 0。

子问题的关系是，向两个字符串其中一个末端添加字符，若该字符与另一个字符串末尾字符相等时， LCS = 不包括末尾相等字符的子串的 LCS + 1 ，不包括其中某个末尾字符子串的 LCS 的较大者。

计算顺序是，从空字符串逐步扩展到两个完整的字符串，i 和 j 来控制考虑的字符串结尾的范围，最开始 i = 0, j = 0（两个空字符串的 LCS），最后 i = m, j = n。根据子问题的关系，计算后续字符串的 LCS 需要不包含末尾字符的子串的 LCS。
